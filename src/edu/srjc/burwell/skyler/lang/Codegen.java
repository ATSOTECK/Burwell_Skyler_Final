/*
 * Skyler Burwell
 * skburwell@gmail.com
 * 19 - May - 2018
 * Burwell_Skyler_Final A simple c-like programming language that allows for variables, functions, and multiple files.
 * It also has a very basic editor to edit the files and compile them.
 * CS 17.11 6991
 * This file takes the node list and emits java code.
 */

package edu.srjc.burwell.skyler.lang;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import static edu.srjc.burwell.skyler.lang.Node.NodeType.*;

public class Codegen
{
    private ArrayList<Node> mNodes;
    private int mDepth = 0;
    private PrintWriter mFile = null;

    private void closeFile()
    {
        mFile.flush();
        mFile.close();
    }

    public Codegen(ArrayList<Node> nodes)
    {
        mNodes = nodes;
        mDepth = 1;
    }

    private void insertTimestamp()
    {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("M/d/yyyy");
        LocalDateTime now = LocalDateTime.now();
        mFile.println(dtf.format(now) + ".");
    }

    private void insertTabs(int n)
    {
        for (int i = 0; i < n; ++i)
        {
            mFile.print("    ");
        }
    }

    private void insertNewlineAndTabs(int n)
    {
        insertNewline();
        insertTabs(n);
    }

    private void insertNewline()
    {
        mFile.println("");
    }

    private void beginBlock()
    {
        insertNewlineAndTabs(mDepth++);
        mFile.println("{");
    }

    private void endBlock( boolean newline)
    {
        insertTabs(--mDepth);
        mFile.print("}");

        if (newline)
        {
            insertNewline();
        }
        else
        {
            mFile.print(" ");
        }
    }

    public void codegen()
    {
        try
        {
            mFile = new PrintWriter("Main.java");
        }
        catch (FileNotFoundException ex)
        {
            System.out.println("Could not save 'Main.java'. Abort codegen.");
            return;
        }

        mFile.println("//");
        mFile.println("//  Main.java");
        mFile.println("//");
        mFile.print("//  Generated by the Yava compiler v 0.0.0 on ");
        insertTimestamp();
        mFile.println("//  All changes made to this file will be overwritten.");
        mFile.println("//");
        insertNewline();

        mFile.println("public class Main");
        mFile.println("{");
        insertNewlineAndTabs(mDepth);
        mFile.print("public static void main(String[] args)");
        insertNewlineAndTabs(mDepth);
        mFile.print("{");
        insertNewlineAndTabs(++mDepth);
        mFile.print("start();");
        insertNewlineAndTabs(--mDepth);
        mFile.print("}");
        insertNewline();

        insertNewlineAndTabs(mDepth);
        mFile.print("public static void println(String str)");
        insertNewlineAndTabs(mDepth);
        mFile.print("{");
        insertNewlineAndTabs(++mDepth);
        mFile.print("System.out.println(str);");
        insertNewlineAndTabs(--mDepth);
        mFile.print("}");
        insertNewline();

        insertNewlineAndTabs(mDepth);
        mFile.print("public static void println(int number)");
        insertNewlineAndTabs(mDepth);
        mFile.print("{");
        insertNewlineAndTabs(++mDepth);
        mFile.print("System.out.println(number);");
        insertNewlineAndTabs(--mDepth);
        mFile.print("}");
        insertNewline();

        insertNewlineAndTabs(mDepth);
        mFile.print("public static void println(float number)");
        insertNewlineAndTabs(mDepth);
        mFile.print("{");
        insertNewlineAndTabs(++mDepth);
        mFile.print("System.out.println(number);");
        insertNewlineAndTabs(--mDepth);
        mFile.print("}");
        insertNewline();

        insertNewlineAndTabs(mDepth);
        mFile.print("public static void println(double number)");
        insertNewlineAndTabs(mDepth);
        mFile.print("{");
        insertNewlineAndTabs(++mDepth);
        mFile.print("System.out.println(number);");
        insertNewlineAndTabs(--mDepth);
        mFile.print("}");
        insertNewline();

        for (Node node : mNodes)
        {
            codegen(node);
        }

        mFile.print("}");

        closeFile();
    }

    private void codegen(Node node)
    {
        switch (node.nodeType())
        {
            case TypeNodeType:
                typeGen((TypeNode)node);
                break;
            case IntNodeType:
                intGen((IntNode)node);
                break;
            case FloatNodeType:
                floatGen((FloatNode)node);
                break;
            case DoubleNodeType:
                doubleGen((DoubleNode)node);
                break;
            case StringNodeType:
                stringGen((StringNode)node);
                break;
            case CharNodeType:
                charGen((CharNode)node);
                break;
            case BoolNodeType:
                boolGen((BoolNode)node);
                break;
            case CallNodeType:
                callGen((CallNode)node);
                break;
            case FunctionNodeType:
                functionGen((FunctionNode)node);
                break;
            case BlockNodeType:
                blockGen((BlockNode)node);
                break;
            case IfNodeType:
                ifGen((IfNode)node, true);
                break;
            case WhileNodeType:
                whileGen((WhileNode)node);
                break;
            case UntilNodeType:
                untilGen((UntilNode)node);
                break;
            case DoNodeType:
                doGen((DoNode)node);
                break;
            case RepeatNodeType:
                repeatGen((RepeatNode)node);
                break;
            case ForeverNodeType:
                foreverGen((ForeverNode)node);
                break;
            case ForRangeNodeType:
                forRangeGen((ForRangeNode)node);
                break;
            case ForNodeType:
                forGen((ForNode)node);
                break;
            case BinaryNodeType:
                binaryGen((BinaryNode)node);
                break;
            case PreDecNodeType:
                preDecGen((PreDecNode)node);
                break;
            case PostDecNodeType:
                postDecGen((PostDecNode)node);
                break;
            case PreIncNodeType:
                preIncGen((PreIncNode)node);
                break;
            case PostIncNodeType:
                postIncGen((PostIncNode)node);
                break;
            case ReturnNodeType:
                returnGen((ReturnNode)node);
                break;
            case VariableNodeType:
                variableGen((VariableNode)node);
                break;
            case VarNodeType:
                varGen((VarNode)node);
                break;
            case LabelNodeType:
                labelGen((LabelNode)node);
                break;
            default:
                System.out.print("Codegen unknown node ");
                System.out.println(node);
        }
    }

    private void typeGen(TypeNode typeNode)
    {
        switch (typeNode.getType())
        {
            case "bool":
                mFile.print("boolean");
                break;
            case "int64":
                mFile.print("long");
                break;
            default:
                mFile.print(typeNode.getType());
                break;
        }
    }

    private void intGen(IntNode intNode)
    {
        mFile.print(intNode.getValue());
    }

    private void floatGen(FloatNode floatNode)
    {
        if (!floatNode.hasDecimal())
        {
            mFile.print(floatNode.getValue() + ".f");
        }
        else
        {
            mFile.print(floatNode.getValue() + "f");
        }
    }

    private void doubleGen(DoubleNode doubleNode)
    {
        if (!doubleNode.hasDecimal())
        {
            mFile.print(doubleNode.getValue() + ".0");
        }
        else
        {
            mFile.print(doubleNode.getValue());
        }
    }

    private void stringGen(StringNode stringNode)
    {
        mFile.print("\"" + stringNode.getStr() + "\"");
    }

    private void charGen(CharNode charNode)
    {
        mFile.print("'" + charNode.getChar() + "'");
    }

    private void boolGen(BoolNode boolNode)
    {
        if (boolNode.value())
        {
            mFile.print("true");
        }
        else
        {
            mFile.print("false");
        }
    }

    private void arrayGen(ArrayNode arrayNode)
    {
        System.err.println("Not yet implemented!");
    }

    private void blockGen(BlockNode block)
    {
        blockGen(block, true, true);
    }

    private void blockGen(BlockNode block, boolean newline)
    {
        blockGen(block, newline, true);
    }

    private void blockGen(BlockNode block, boolean newline, boolean braces)
    {
        if (braces)
        {
            beginBlock();
        }

        for (Node node : block.getStatements())
        {
            if (node.nodeType() == EmptyNodeType)
            {
                continue;
            }

            insertTabs(mDepth);

            codegen(node);
            if (needsSemicolon(node))
            {
                mFile.print(";");
                insertNewline();
            }
        }

        if (braces)
        {
            endBlock(newline);
        }
    }

    private void ifGen(IfNode ifNode, boolean newline)
    {
        if (newline)
        {
            insertNewlineAndTabs(mDepth);
        }

        mFile.print("if (");
        codegen(ifNode.getCondition());
        mFile.print(")");
        blockGen(ifNode.getCode(), ifNode.getOther() == null);

        if (ifNode.getOther() != null)
        {
            insertNewlineAndTabs(mDepth);
            mFile.print("else ");

            if (ifNode.isElseIf())
            {
                ifGen((IfNode)ifNode.getOther(), false);
            }
            else
            {
                elseGen((ElseNode)ifNode.getOther());
            }
        }
    }

    private void elseGen(ElseNode elseNode)
    {
        blockGen(elseNode.getCode());
    }

    private void callGen(CallNode callNode)
    {
        mFile.print(callNode.getCallee());
        mFile.print("(");

        for (int i = 0; i < callNode.getArgs().size(); ++i)
        {
            codegen(callNode.getArgs().get(i));

            if (i + 1 < callNode.getArgs().size())
            {
                mFile.print(", ");
            }
        }

        mFile.print(")");
    }

    private void functionGen(FunctionNode functionNode)
    {
        if (functionNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);

        mFile.print("public static ");
        codegen(functionNode.getPrototype().getReturnType());
        mFile.print(" " + functionNode.getPrototype().getName() + "(");

        int numargs = functionNode.getPrototype().getArgs().size();
        for (int i = 0; i < numargs; ++i)
        {
            codegen(((VarNode)functionNode.getPrototype().getArgs().get(i)).getType());
            mFile.print(" ");
            mFile.print(((VarNode)functionNode.getPrototype().getArgs().get(i)).getName());

            if (i + 1 < numargs)
            {
                mFile.print(", ");
            }
        }

        mFile.print(")");
        blockGen(functionNode.getBody());
    }

    private void whileGen(WhileNode whileNode)
    {
        if (whileNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        mFile.print("while (");
        codegen(whileNode.getCondition());
        mFile.print(")");
        blockGen(whileNode.getBody());
        insertNewline();
    }

    private void untilGen(UntilNode untilNode)
    {
        if (untilNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        mFile.print("while (!(");
        codegen(untilNode.getCondition());
        mFile.print("))");
        blockGen(untilNode.getBody());
        insertNewline();
    }

    private void doGen(DoNode doNode)
    {
        if (doNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        mFile.print("do ");
        blockGen(doNode.getBody(), false);

        if (doNode.isWhile())
        {
            mFile.print("while (");
        }
        else
        {
            mFile.print("while (!(");
        }

        codegen(doNode.getCondition());

        if (doNode.isWhile())
        {
            mFile.print(");");
        }
        else
        {
            mFile.print("));");
        }

        insertNewline();
        insertNewline();
    }

    private void repeatGen(RepeatNode repeatNode)
    {
        if (repeatNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewline();
        //TODO: Check if it is the correct type.
        int count = ((IntNode)repeatNode.getCondition()).getValue();

        for (int i = 0; i < count; ++i)
        {
            blockGen(repeatNode.getBody(), true, false);
        }

        insertNewline();
    }

    private void foreverGen(ForeverNode foreverNode)
    {
        if (foreverNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        mFile.print("for (;;) ");
        blockGen(foreverNode.getBody());
        insertNewline();
    }

    private void forRangeGen(ForRangeNode forRangeNode)
    {
        if (forRangeNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        boolean up = true;

        mFile.print("for (int ");
        mFile.print(forRangeNode.getName() + " = ");
        codegen(forRangeNode.getStart());
        mFile.print("; " + forRangeNode.getName() + " ");

        if (forRangeNode.getStart().nodeType() == IntNodeType && forRangeNode.getStop().nodeType() == IntNodeType)
        {
            int startValue = ((IntNode)forRangeNode.getStart()).getValue();
            int stopValue = ((IntNode)forRangeNode.getStop()).getValue();

            if (startValue < stopValue)
            {
                mFile.print(" <= ");
                up = true;
            }
            else
            {
                mFile.print(" >= ");
                up = false;
            }
        }
        else
        {
            //TODO: Assumption.
            mFile.print(" <= ");
            up = true;
        }

        codegen(forRangeNode.getStop());
        mFile.print("; " + forRangeNode.getName() + " ");

        if (up)
        {
            mFile.print("+= ");
        }
        else
        {
            mFile.print("-= ");
        }

        if (forRangeNode.getStep().nodeType() == EmptyNodeType)
        {
            mFile.print("1");
        }
        else
        {
            codegen(forRangeNode.getStep());
        }

        mFile.print(")");
        blockGen(forRangeNode.getBody());
    }

    private void forGen(ForNode forNode)
    {
        if (forNode.getBody().getStatements().size() == 0)
        {
            return;
        }

        insertNewlineAndTabs(mDepth);
        mFile.print("for (");
        codegen(forNode.getStart());
        mFile.print("; ");
        codegen(forNode.getCondition());
        mFile.print("; ");
        codegen(forNode.getExpression());
        mFile.print(")");
        blockGen(forNode.getBody());
    }

    private void unaryGen(UnaryNode unaryNode)
    {
        //TODO
    }

    private void binaryGen(BinaryNode binaryNode)
    {
        codegen(binaryNode.getLHS());
        mFile.print(" " + binaryNode.getOP().lexeme() + " ");
        codegen(binaryNode.getRHS());
    }

    private void preDecGen(PreDecNode preDecNode)
    {
        mFile.print("--");
        codegen(preDecNode.getExpression());
    }

    private void postDecGen(PostDecNode postDecNode)
    {
        codegen(postDecNode.getExpression());
        mFile.print("--");
    }

    private void preIncGen(PreIncNode preIncNode)
    {
        mFile.print("++");
        codegen(preIncNode.getExpression());
    }

    private void postIncGen(PostIncNode postIncNode)
    {
        codegen(postIncNode.getExpression());
        mFile.print("++");
    }

    private void returnGen(ReturnNode returnNode)
    {
        insertNewlineAndTabs(mDepth);
        mFile.print("return ");
        codegen(returnNode.getReturnStatement());
    }

    private void variableGen(VariableNode variableNode)
    {
        mFile.print(variableNode.getName());
    }

    private void varGen(VarNode varNode)
    {
        if (varNode.isVar())
        {
            codegen(varNode.getType());
            mFile.print(" ");
        }
        else
        {
            mFile.print("final ");
            codegen(varNode.getType());
            mFile.print(" ");
        }

        if (varNode.getValue() == null)
        {
            mFile.print(varNode.getName());
        }
        else
        {
            mFile.print(varNode.getName() + " = ");
            codegen(varNode.getValue());
        }
    }

    private void labelGen(LabelNode labelNode)
    {
        mFile.print(labelNode.getName() + ":");
        insertNewline();
    }

    private boolean needsSemicolon(Node node)
    {
        switch (node.nodeType())
        {
            case WhileNodeType:
            case UntilNodeType:
            case FunctionNodeType:
            case BlockNodeType:
            case IfNodeType:
            case ElseNodeType:
            case RepeatNodeType:
            case ForeverNodeType:
            case LabelNodeType:
            case ForNodeType:
            case ForRangeNodeType:
            case DoNodeType:
                return false;
            default:
                return true;
        }
    }
}
